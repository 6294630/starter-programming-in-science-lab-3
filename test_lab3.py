# DO NOT EDIT THIS FILE!! 
# IF MODIFIED IN ANY WAY, YOU WILL RECEIVE 0 FOR THE GRADE!

import pytest
import math
from Lab3 import polar_to_cartesian, cartesian_to_polar, calculate_position

def test_polar_to_cartesian():
    # Test Case 1: Basic case
    assert polar_to_cartesian(1, 0) == (1, 0)

    # Test Case 2: 90 degrees (π/2 radians)
    assert polar_to_cartesian(1, math.pi / 2) == pytest.approx((0, 1), rel=1e-5)

    # Test Case 3: 45 degrees (π/4 radians)
    assert polar_to_cartesian(1, math.pi / 4) == pytest.approx((math.sqrt(2) / 2, math.sqrt(2) / 2), rel=1e-5)

    # Test Case 4: Zero radius
    assert polar_to_cartesian(0, math.pi / 3) == (0, 0)


def test_cartesian_to_polar():
    # Test Case 1: Origin (0,0)
    assert cartesian_to_polar(0, 0) == (0, 0)

    # Test Case 2: Positive x-axis
    assert cartesian_to_polar(1, 0) == (1, 0)

    # Test Case 3: Positive y-axis
    assert cartesian_to_polar(0, 1) == pytest.approx((1, math.pi / 2), rel=1e-5)

    # Test Case 4: Negative x-axis
    assert cartesian_to_polar(-1, 0) == pytest.approx((1, math.pi), rel=1e-5)

    # Test Case 5: Negative y-axis
    assert cartesian_to_polar(0, -1) == pytest.approx((1, -math.pi / 2), rel=1e-5)

    # Test Case 6: General case (1,1) -> r = sqrt(2), θ = π/4
    assert cartesian_to_polar(1, 1) == pytest.approx((math.sqrt(2), math.pi / 4), rel=1e-5)

    # Test Case 7: General case (-1, -1) -> r = sqrt(2), θ = -3π/4
    assert cartesian_to_polar(-1, -1) == pytest.approx((math.sqrt(2), -3 * math.pi / 4), rel=1e-5)

def test_calculate_position():
    # Test 1: Standard case
    A, f, Φ, t = 2, 1, 0, 0.25
    expected = 2 * math.sin(2 * math.pi * 1 * 0.25 + 0)
    assert calculate_position(A, f, Φ, t) == pytest.approx(expected, rel=1e-5)
    
    # Test 2: Zero amplitude (should always return 0)
    A, f, Φ, t = 0, 1, 0, 0.5
    assert calculate_position(A, f, Φ, t) == 0
    
    # Test 3: Zero frequency (should return A*sin(Φ))
    A, f, Φ, t = 2, 0, math.pi/2, 1
    assert calculate_position(A, f, Φ, t) == pytest.approx(A * math.sin(Φ), rel=1e-5)
    
    # Test 4: Zero phase shift (Φ = 0)
    A, f, Φ, t = 1, 2, 0, 0.5
    expected = 1 * math.sin(2 * math.pi * 2 * 0.5)
    assert calculate_position(A, f, Φ, t) == pytest.approx(expected, rel=1e-5)
    
    # Test 5: Floating-point precision check
    A, f, Φ, t = 3, 0.5, math.pi/4, 2
    expected = 3 * math.sin(2 * math.pi * 0.5 * 2 + math.pi/4)
    assert calculate_position(A, f, Φ, t) == pytest.approx(expected, rel=1e-5)
